# 式
基本的に式は、内部では最初の要素とそれ以降の要素すべてを入れたリストの２つを構造体で管理しています。<br>
詳細は interpreter/ のほうに書く予定ですが、簡単にいうと `1 + 2 + 3` という式であれば `{1, {2, 3}}` というようになります。<br>

例外１：連続して並べられないものは２つだけ入れるようにしている (`a .. b` とか) <br>
例外２：比較式とビット演算はすべて一つのリストに入れています　これにより `a < b > c` を実現している <br>


## 演算子の優先順位

|   |                 |                         |
|---|-----------------|-------------------------|
|1  | factor          | 即値 変数 関数呼び出し
|2  | primary         | `[...]` 配列 `dicst<T, U>{ ... }`辞書(型付) `cast<T>(...)`キャスト
|3  | unary           | `+` 前置きインクリメント `-`前置きデクリメント
|4  | indexref        | `[ ]` 配列添字
|5  | member_access   | `.` メンバアクセス
|6  | mul             | `*` `/` `%`
|7  | add             | `+` `-`
|8  | shift           | `<<` `>>`
|9  | compare         | `==` `!=` `>=` `<=` `>` `<`
|10 | bit_op          | `&` `^` `\|`
|11 | log_and_or      | `&&` `\|\|`
|12 | range           | `..`
|13 | assign          | `=`

# factor
## 即値
- int, float, char, string
- boolean は予約語 `true` `false` どちらかで表す
- none は `none` そのまま

## 変数
TOK\_Ident

## 関数呼び出し
```
callfunc = ident "(" (expr ("," expr)*)? ")"
```
